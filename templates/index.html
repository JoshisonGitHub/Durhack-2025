<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebRTC Flask Live Streaming</title>
    <style>
    button {
        padding: 8px 16px;
    }

    pre {
        overflow-x: hidden;
        overflow-y: auto;
    }

    video {
        width: 100%;
    }

    .option {
        margin-bottom: 8px;
    }

    #media {
        max-width: 1280px;
    }
    </style>
</head>
<body>

<h2>Options</h2>
<div class="option">
    <input id="use-datachannel" checked="checked" type="checkbox"/>
    <label for="use-datachannel">Use datachannel</label>
    <select id="datachannel-parameters">
        <option value='{"ordered": true}'>Ordered, reliable</option>
        <option value='{"ordered": false, "maxRetransmits": 0}'>Unordered, no retransmissions</option>
        <option value='{"ordered": false, "maxPacketLifetime": 500}'>Unordered, 500ms lifetime</option>
    </select>
</div>
<div class="option">
    <input id="use-audio" checked="checked" type="checkbox"/>
    <label for="use-audio">Use audio</label>
    <select id="audio-input">
        <option value="" selected>Default device</option>
    </select>
    <select id="audio-codec">
        <option value="default" selected>Default codecs</option>
        <option value="opus/48000/2">Opus</option>
        <option value="PCMU/8000">PCMU</option>
        <option value="PCMA/8000">PCMA</option>
    </select>
</div>
<div class="option">
    <input id="use-video" type="checkbox"/>
    <label for="use-video">Use video</label>
    <select id="video-input">
        <option value="" selected>Default device</option>
    </select>
    <select id="video-resolution">
        <option value="" selected>Default resolution</option>
        <option value="320x240">320x240</option>
        <option value="640x480">640x480</option>
        <option value="960x540">960x540</option>
        <option value="1280x720">1280x720</option>
    </select>
    <select id="video-transform">
        <option value="none" selected>No transform</option>
        <option value="edges">Edge detection</option>
        <option value="cartoon">Cartoon effect</option>
        <option value="rotate">Rotate</option>
    </select>
    <select id="video-codec">
        <option value="default" selected>Default codecs</option>
        <option value="VP8/90000">VP8</option>
        <option value="H264/90000">H264</option>
    </select>
</div>
<div class="option">
    <input id="use-stun" type="checkbox"/>
    <label for="use-stun">Use STUN server</label>
</div>

<button id="start" onclick="start()">Start</button>
<button id="stop" style="display: none" onclick="stop()">Stop</button>

<h2>State</h2>
<p>
    ICE gathering state: <span id="ice-gathering-state"></span>
</p>
<p>
    ICE connection state: <span id="ice-connection-state"></span>
</p>
<p>
    Signaling state: <span id="signaling-state"></span>
</p>

<div id="media" style="display: none">
    <h2>Media</h2>

    <audio id="audio" autoplay="true"></audio>
    <video id="video" autoplay="true" playsinline="true"></video>
</div>

<h2>Data channel</h2>
<pre id="data-channel" style="height: 200px;"></pre>

<h2>SDP</h2>

<h3>Offer</h3>
<pre id="offer-sdp"></pre>

<h3>Answer</h3>
<pre id="answer-sdp"></pre>

<script src="static/main.js"></script>
<!--
<script>
    // Use relative URL so it works regardless of IP/host:
    const PRESS_URL = "/press";

    const video = document.getElementById('cam');
    const statusEl = document.getElementById('status');
    const toast = document.getElementById('toast');
    const errBox = document.getElementById('err');
    const actionBtn = document.getElementById('actionBtn');
    const toggleBtn = document.getElementById('toggleFacing');
    const pauseBtn = document.getElementById('pauseResume');

    let stream = null;
    let facing = 'environment'; // start with rear camera if available
    let busy = false;
    let wakeLock = null;

    function showToast(msg) {
      toast.textContent = msg;
      toast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toast.classList.remove('show'), 1200);
    }
    function showError(msg) {
      errBox.textContent = msg;
      errBox.classList.remove('hidden');
    }
    function clearError() {
      errBox.classList.add('hidden');
      errBox.textContent = '';
    }
    function haptics() {
      if (navigator.vibrate) navigator.vibrate(10);
    }

    async function getStream() {
      clearError();
      // Stop old tracks
      if (stream) stream.getTracks().forEach(t => t.stop());
      const constraints = {
        audio: false,
        video: {
          facingMode: { ideal: facing },     // 'environment' or 'user'
          width: { ideal: 1280 },
          height: { ideal: 720 }
        }
      };
      try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        statusEl.textContent = `Camera: ${facing === 'environment' ? 'Rear' : 'Front'}`;
        // Autoplay on iOS requires user gesture if not muted; video is muted, playsinline.
        await video.play().catch(() => {});
        //startWebRTC();
      } catch (e) {
        console.error(e);
        let msg = String(e && e.message || e);
        if (/secure context|https/i.test(msg)) {
          msg = "Camera blocked: many browsers require HTTPS for camera access on local IPs. \
Tip: use an HTTPS tunnel (e.g., ngrok/Cloudflared) or run with a local certificate.";
        } else if (/NotAllowedError/i.test(msg)) {
          msg = "Camera permission denied. Please allow camera access in your browser settings.";
        } else if (/NotFoundError|OverconstrainedError/i.test(msg)) {
          msg = "Requested camera not available. Try flipping cameras.";
        }
        statusEl.textContent = "Camera: error";
        showError(msg);
      }
    }

    async function toggleFacingMode() {
      facing = (facing === 'environment') ? 'user' : 'environment';
      await getStream();
    }

    function pauseResume() {
      if (!stream) return;
      const tracks = stream.getVideoTracks();
      if (tracks.length) {
        const t = tracks[0];
        if (t.enabled) {
          t.enabled = false;
          pauseBtn.textContent = "Resume";
          statusEl.textContent = "Camera: paused";
        } else {
          t.enabled = true;
          pauseBtn.textContent = "Pause";
          statusEl.textContent = `Camera: ${facing === 'environment' ? 'Rear' : 'Front'}`;
        }
      }
    }

    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible' && wakeLock && wakeLock.released) {
              wakeLock = await navigator.wakeLock.request('screen');
            }
          });
        }
      } catch {}
    }

    async function sendPress() {
      if (busy) return;
      busy = true; actionBtn.disabled = true; haptics();
      try {
        const res = await fetch(PRESS_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          cache: 'no-store',
          body: JSON.stringify({ t: Date.now(), source: 'phone' }),
          keepalive: true
        });
        if (!res.ok) throw new Error('HTTP '+res.status);
        showToast('Sent ✅');
      } catch (e) {
        // Fallback GET (works even if CORS settings get weird)
        try {
          const img = new Image();
          img.src = PRESS_URL + (PRESS_URL.includes('?') ? '&' : '?') + 't=' + Date.now();
          await new Promise(r => setTimeout(r, 300));
          showToast('Sent (fallback) ✅');
        } catch { showToast('Failed ❌'); }
      } finally {
        setTimeout(() => { busy = false; actionBtn.disabled = false; }, 250);
      }
    }

    toggleBtn.addEventListener('click', toggleFacingMode);
    pauseBtn.addEventListener('click', pauseResume);
    actionBtn.addEventListener('click', sendPress);

    // Kick things off after a user gesture (helps iOS)
    window.addEventListener('load', () => {
      // If permissions were already granted, start immediately
      getStream(); requestWakeLock();
    });

    // Prevent double-tap zoom on iOS
    let lastTouch = 0;
    document.addEventListener('touchend', e => {
      const now = Date.now();
      if (now - lastTouch <= 300) e.preventDefault();
      lastTouch = now;
    }, { passive: false });
    /*
    // --- WebRTC uplink to server ---
    let pc = null;
    async function startWebRTC() {
      if (!stream) return;
      if (pc) { try { pc.close(); } catch {} pc = null; }

      pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
      const signaler = new WebSocket('ws://ar.durgun.space/signal');
      stream.getTracks().forEach(t => pc.addTrack(t, stream));

      pc.oniceconnectionstatechange = () => {
        const s = pc.iceConnectionState;
        if (s === 'connected') statusEl.textContent = 'Camera: streaming to server';
        if (s === 'failed' || s === 'disconnected') statusEl.textContent = 'Camera: connection lost';
      };

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await new Promise(resolve => {
        if (pc.iceGatheringState === 'complete') resolve();
        else pc.addEventListener('icegatheringstatechange', () => {
          if (pc.iceGatheringState === 'complete') resolve();
        });
      });

      const resp = await fetch('/offer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sdp: pc.localDescription.sdp, type: pc.localDescription.type }),
      });
      if (!resp.ok) { console.error('Offer failed', resp.status); return; }
      const answer = await resp.json();
      await pc.setRemoteDescription(answer);

      pc.ontrack = ({ track, streams }) => {
      track.onunmute = () => {
        if (remoteVideo.srcObject) {
          return;
        }
        remoteVideo.srcObject = streams[0];
      };
    };

    let makingOffer = false;

    pc.onnegotiationneeded = async () => {
      try {
        makingOffer = true;
        await pc.setLocalDescription();
        signaler.send({ description: pc.localDescription });
      } catch (err) {
        console.error(err);
      } finally {
        makingOffer = false;
      }
    };
    pc.onicecandidate = ({ candidate }) => signaler.send({ candidate });

    let ignoreOffer = false;
let isSettingRemoteAnswerPending = false;

signaler.onmessage = async ({ data: { description, candidate } }) => {
  try {
    if (description) {
      const readyForOffer =
        !makingOffer &&
        (pc.signalingState === "stable" || isSettingRemoteAnswerPending);
      const offerCollision = description.type === "offer" && !readyForOffer;

      ignoreOffer = !polite && offerCollision;
      if (ignoreOffer) {
        return;
      }
      isSettingRemoteAnswerPending = description.type === "answer";
      await pc.setRemoteDescription(description);
      isSettingRemoteAnswerPending = false;
      if (description.type === "offer") {
        await pc.setLocalDescription();
        signaler.send({ description: pc.localDescription });
      }
    } else if (candidate) {
      try {
        await pc.addIceCandidate(candidate);
      } catch (err) {
        if (!ignoreOffer) {
          throw err;
        }
      }
    }
  } catch (err) {
    console.error(err);
  }
};
    }*/
    var pc = null;

function negotiate() {
    pc.addTransceiver('video', {direction: 'recvonly'});
    pc.addTransceiver('audio', {direction: 'recvonly'});
    return pc.createOffer().then(function(offer) {
        return pc.setLocalDescription(offer);
    }).then(function() {
        // wait for ICE gathering to complete
        return new Promise(function(resolve) {
            if (pc.iceGatheringState === 'complete') {
                resolve();
            } else {
                function checkState() {
                    if (pc.iceGatheringState === 'complete') {
                        pc.removeEventListener('icegatheringstatechange', checkState);
                        resolve();
                    }
                }
                pc.addEventListener('icegatheringstatechange', checkState);
            }
        });
    }).then(function() {
        var offer = pc.localDescription;
        return fetch('/offer', {
            body: JSON.stringify({
                sdp: offer.sdp,
                type: offer.type,
            }),
            headers: {
                'Content-Type': 'application/json'
            },
            method: 'POST'
        });
    }).then(function(response) {
        return response.json();
    }).then(function(answer) {
        return pc.setRemoteDescription(answer);
    }).catch(function(e) {
        alert(e);
    });
  }

  function start() {
  var config = {
      sdpSemantics: 'unified-plan'
  };

  if (document.getElementById('use-stun').checked) {
      config.iceServers = [{urls: ['stun:stun.l.google.com:19302']}];
  }

  pc = new RTCPeerConnection(config);

  // connect audio / video
  pc.addEventListener('track', function(evt) {
      if (evt.track.kind == 'video') {
          document.getElementById('video').srcObject = evt.streams[0];
      } else {
          document.getElementById('audio').srcObject = evt.streams[0];
      }
  });

  document.getElementById('start').style.display = 'none';
  negotiate();
  document.getElementById('stop').style.display = 'inline-block';
  }

  function stop() {
  document.getElementById('stop').style.display = 'none';

  // close peer connection
  setTimeout(function() {
      pc.close();
  }, 500);
  }

  window.addEventListener('beforeunload', () => { try { pc && pc.close(); } catch {} });
<--
</script>
</body>
</html>